
## Engenharia reversa e hacking de memÃ³ria com Cheat Engine

O que estamos fazendo?

Vamos modificar instruÃ§Ãµes na memÃ³ria do programa.

A ideia Ã© que, ao clicar em um botÃ£o (HIT ME)  no programa, ao invÃ©s de diminuir um valor, ele aumente.

Mas, antes de fazermos essa alteraÃ§Ã£o, precisamos encontrar o endereÃ§o onde esse valor estÃ¡ armazenado. 

Primeir passo Ã© ir no modo de treino do *CE*

![alt text](image.png)

E dar ok ou next atÃ© a etapa chegar na 7 ou (Step 7)

![alt text](image-1.png)
nessa etaÃ¡ tem o botÃ£o que precisaremos modificar o seu evento.

Selecione o processo que iremos trabalhar, que nesse caso Ã© o tutorial.
![alt text](image-2.png)

Iremos sacaner o valor, que no meu caso Ã© *99* atÃ© achar o endereÃ§o de memoria.
![alt text](image-3.png)

No meu caso o endereÃ§o Ã© *0176B600*
![alt text](image-4.png)

Apos seleciona a memoria precisaremos ir para o modo de depuraÃ§Ã£o/debugger do CE

**(Find out what accesses this address F5)**
![alt text](image-5.png)

Ao clicar em (HIT ME) irÃ¡ aprensetar o evento em tela sobre o endereÃ§o que estamos observado, que no meu caso *0176B600*
![alt text](image-6.png)

Conforme a instruction teremos as inforamÃ§Ãµes na lateral de
**Copy memory** como **leitura/reading** e **subtract** como **escrita/writing**

Com a instruÃ§Ã£o selecionada iremos usar o "show disassembler";
![alt text](image-7.png) 

Ira mostrar a tela de Memory Viewer
![alt text](image-8.png)

Vamos analisar essa instruÃ§Ã£o de **Assembly** passo a passo:

### **InstruÃ§Ã£o:**  
```assembly
"Tutorial-i386.exe"+28A78 - sub dword ptr [ebx+000004A8],01
```

### **Quebrando a instruÃ§Ã£o**
1. **"Tutorial-i386.exe"+28A78**  
   - Esse endereÃ§o refere-se a um deslocamento (`offset`) dentro do **executÃ¡vel** `Tutorial-i386.exe`.  
   - O `28A78` Ã© um deslocamento dentro da memÃ³ria onde esse cÃ³digo estÃ¡ sendo executado.  

2. **`sub dword ptr [ebx+000004A8],01`**  
   - **`sub`** â†’ Subtrai um valor do operando especificado.  
   - **`dword ptr [ebx+000004A8]`** â†’ Refere-se a um valor de **4 bytes (DWORD)** armazenado na memÃ³ria no endereÃ§o `[ebx + 4A8]`.  
   - **`01`** â†’ Subtrai `1` desse valor.

### **O que essa linha faz?**
Ela diminui em **1** o valor armazenado na memÃ³ria, no endereÃ§o **`[ebx+4A8]`**.

### **ProvÃ¡vel Uso no Programa**
- **`ebx`** no nosso caso da um **Hit me** no ''jogo/programa''.
- **`[ebx+4A8]`** representa uma variÃ¡vel numÃ©rica, como para os Pontos de vida (HP).

Se esse cÃ³digo estiver relacionado a um jogo, essa linha pode representar, por exemplo:
- **DiminuiÃ§Ã£o da vida do jogador ou inimigo** ao ser atingido.
- **Gasto de um recurso**, como muniÃ§Ã£o ou dinheiro.
- **ReduÃ§Ã£o de um temporizador.**

---

### **Como Explorar essa InstruÃ§Ã£o?**
Se quisermos modificar ou manipular esse comportamento, podemos:
1. **Interceptar essa linha com um script em Cheat Engine** e impedir a reduÃ§Ã£o (`NOP` a instruÃ§Ã£o).  
2. **Modificar o valor diretamente** para um nÃºmero fixo (ex.: saÃºde infinita).  
3. **Alterar o cÃ³digo para inverter o efeito** (ex.: somar em vez de subtrair).  
   - **Exemplo de modificaÃ§Ã£o:**  
     ```assembly
     add dword ptr [ebx+000004A8],01  ; Agora aumentarÃ¡ em vez de diminuir.
     ```
---

### **Resumo**
Essa linha subtrai **1** do valor armazenado em `[ebx+4A8]`, que pode ser qualquer variÃ¡vel no programa (vida, dinheiro, tempo, etc.). Se quisermos explorar isso, podemos manipulÃ¡-la para impedir a reduÃ§Ã£o ou atÃ© inverter seu efeito.
---

Com o endereÃ§o/Address selecionado iremos no menu e clicar em **Tools** e procurar por **Auto Assembler**
![alt text](image-9.png)

Agora ira abrir uma nova janela chamda **Auto Assembler** e iremos no menu dessa janela em  **Template** e **AOB Injection** 
![alt text](image-10.png)

OBS: **Assembly** Ã© uma linguagem intermediÃ¡ria entre bytecode e cÃ³digo legÃ­vel por humanos.
**AOB** (**Array of Bytes**) Ã© uma **sequÃªncia de bytes** usada como **assinatura** para localizar um bloco de cÃ³digo na memÃ³ria. Isso Ã© Ãºtil porque **endereÃ§os de memÃ³ria podem mudar** cada vez que um programa ou jogo Ã© executado, mas a assinatura AOB pode ser usada para encontrar o cÃ³digo certo **mesmo se ele mudar de endereÃ§o**

Proximmo passo Ã© Ã© entrar no **Modelo de injeÃ§Ã£o ou Code injection template** que ira pergunta:

Em qual endereÃ§o vocÃª quer o salto?
```assembly
"Tutorial-i386.exe"+28A78
```
Iremos com *ok*
![alt text](image-11.png)

Depois teremos um nova janela pergunto sobre

**Modelo de injeÃ§Ã£o de cÃ³digo**

**Qual nome vocÃª quer dar ao sÃ­mbolo para o ponto de injeÃ§Ã£o?**

iremos com:
```
INJEC
```
![alt text](image-12.png)
Assim que o comando que irÃ¡ injetar o nosos cocigo for ativado ficar com o EndereÃ§o como texto **INJEC**

### **ExplicaÃ§Ã£o do CÃ³digo do Auto Assembler no Cheat Engine**

Esse cÃ³digo Ã© um **script de injeÃ§Ã£o de cÃ³digo (Code Injection)** usado no **Cheat Engine**. Ele modifica o comportamento do programa **"Tutorial-i386.exe"**, especificamente alterando a instruÃ§Ã£o que decrementa um valor na memÃ³ria.

## Em sequidar irÃ¡ criar um script como templte

# **Estrutura Geral do Script**
O script estÃ¡ dividido em **seÃ§Ãµes**:

1. **CabeÃ§alho** (comentÃ¡rios explicativos)
2. **[ENABLE]** â€“ CÃ³digo que serÃ¡ ativado ao habilitar o script.
3. **[DISABLE]** â€“ CÃ³digo que serÃ¡ restaurado quando o script for desativado.
4. **ComentÃ¡rios** â€“ Explicam onde o cÃ³digo estÃ¡ sendo injetado.

---

## **ðŸ”¹ CabeÃ§alho**
```assembly
{ Game   : Tutorial-i386.exe
  Version: 
  Date   : 2025-03-07
  Author : User

  This script does blah blah blah
}
```
- Apenas **comentÃ¡rios** que documentam o script.  
- `{}` Ã© usado para criar blocos de comentÃ¡rio no Cheat Engine.  
- Aqui, o autor nÃ£o preencheu os detalhes sobre a versÃ£o e funcionalidade especÃ­fica.

---

## **ðŸ”¹ SeÃ§Ã£o [ENABLE] (Ativar o Cheat)**
Esta parte **injeta o cÃ³digo modificado** na memÃ³ria do jogo.

### **1. Procurando um PadrÃ£o de Bytes com `aobscanmodule`**
```assembly
aobscanmodule(INJECT,Tutorial-i386.exe,83 AB A8 04 00 00 01) // should be unique
```
- **`aobscanmodule`** busca um **Array of Bytes (AOB)** dentro do mÃ³dulo `Tutorial-i386.exe`.
- A assinatura **`83 AB A8 04 00 00 01`** representa a instruÃ§Ã£o `sub dword ptr [ebx+000004A8],01`, que **subtrai 1 de um valor armazenado na memÃ³ria**.
- Isso garante que o cÃ³digo serÃ¡ injetado **no local correto**, mesmo que o endereÃ§o mude entre execuÃ§Ãµes.

---

### **2. Criando MemÃ³ria para o CÃ³digo Modificado**
```assembly
alloc(newmem,$1000)
```
- **`alloc(newmem,$1000)`** â†’ Aloca **4 KB (0x1000 bytes)** de memÃ³ria para armazenar o novo cÃ³digo.
- **`newmem`** serÃ¡ o nome do bloco de memÃ³ria.

---

### **3. Criando RÃ³tulos (Labels)**
```assembly
label(code)
label(return)
```
- Define **marcadores (labels)** chamados `code` e `return` para organizar o fluxo do script.

---

### **4. Criando o CÃ³digo Modificado**
```assembly
newmem:

code:
  sub dword ptr [ebx+000004A8],01
  jmp return
```
- `sub dword ptr [ebx+000004A8],01` â†’ **MantÃ©m a instruÃ§Ã£o original** que diminui o valor em `[ebx+4A8]` por 1.
- `jmp return` â†’ ApÃ³s a modificaÃ§Ã£o, **redireciona a execuÃ§Ã£o de volta ao cÃ³digo original**, evitando falhas.

#### Agora iremos modificar o evento para aumentaer em 2:

Em `newmem`, modificamos a lÃ³gica para somar 2 ao invÃ©s de subtrair 1.
```assembly
newmem:
  add dword ptr [ebx+000004A8],02
code:
  //sub dword ptr [ebx+000004A8],01
  jmp return
```
*Assim atingimos objetivo do desafio*
---

### **5. Redirecionando o CÃ³digo Original**
```assembly
INJECT:
  jmp newmem
  nop 2
return:
```
- `jmp newmem` â†’ **Redireciona** o cÃ³digo original para executar `newmem`, onde o cÃ³digo modificado serÃ¡ executado.
- `nop 2` â†’ Insere **NOPs (No Operation)** para preencher os bytes restantes, garantindo que o jogo nÃ£o quebre.

---

### **6. Registrando o SÃ­mbolo**
```assembly
registersymbol(INJECT)
```
- **`registersymbol(INJECT)`** â†’ Registra o endereÃ§o `INJECT` para que possa ser usado em outras partes do Cheat Engine.

---

## **ðŸ”¹ SeÃ§Ã£o [DISABLE] (Desativar o Cheat)**
Quando o cheat Ã© **desativado**, o cÃ³digo original Ã© restaurado.

### **1. Restaurando a InstruÃ§Ã£o Original**
```assembly
INJECT:
  db 83 AB A8 04 00 00 01
```
- **`db` (Define/Declare Bytes)** â†’ Reescreve manualmente os bytes da instruÃ§Ã£o original `sub dword ptr [ebx+000004A8],01`, restaurando o funcionamento normal.

---

### **2. Limpando a MemÃ³ria e SÃ­mbolos**
```assembly
unregistersymbol(INJECT)
dealloc(newmem)
```
- **`unregistersymbol(INJECT)`** â†’ Remove `INJECT` da lista de sÃ­mbolos do Cheat Engine.
- **`dealloc(newmem)`** â†’ Libera a memÃ³ria alocada anteriormente para evitar desperdÃ­cio de recursos.

---

## **ðŸ”¹ Trecho do CÃ³digo Original do Jogo**
Abaixo do script, hÃ¡ um trecho do cÃ³digo original do jogo com a Ã¡rea de injeÃ§Ã£o destacada:
```assembly
"Tutorial-i386.exe"+28A78: 83 AB A8 04 00 00 01  - sub dword ptr [ebx+000004A8],01  // INJECTING HERE
```
Isso mostra exatamente **onde** a injeÃ§Ã£o ocorre no cÃ³digo do jogo.

---

## **ðŸ“Œ Resumo**
ðŸ”¹ **Esse script injeta cÃ³digo no jogo "Tutorial-i386.exe" e modifica a instruÃ§Ã£o `sub dword ptr [ebx+000004A8],01`**.  
ðŸ”¹ **AOB Scan** Ã© usado para encontrar a instruÃ§Ã£o correta na memÃ³ria, garantindo que o script funcione mesmo que os endereÃ§os mudem.  
ðŸ”¹ **Ao ativar, o script desvia a execuÃ§Ã£o para o cÃ³digo modificado, mantendo o comportamento original.**  
ðŸ”¹ **Ao desativar, ele restaura os bytes originais e limpa a memÃ³ria.**  


###  Quando terminar de fazer a alterÃ§Ã£o iremos criar a nossa tabela em 
*Fiel -> + Assign to current cheat table*
![alt text](image-13.png)

A fazer isso podemos fechar e voltar para tela principal do Cheat Engien;
![alt text](image-14.png)

Tendo agora duas intruÃ§Ãµes a primeira do scan e a seungo com o script recem criado.

Dando dos click em `<script>` na colunas Value podemos visualisar o codigo e alterar novamente.
Agora quando marco a caixa para injetar o meu codigo iremos ver a alteraÃ§Ã£o em *Memory Viewer*
![alt text](image-15.png)

Ao selecionar EndereÃ§o/Address em *Memory Viewer* e buscar por *Follow*
![alt text](image-16.png)

Poderemos ver o codigo *add* que aumento implementado na memoria
![alt text](image-17.png)

E assim au dismarcar a caixa poderemos contrar o evento de adicionar e remover.

OBS: Caso tenh perdido o local do endereÃ§o por algum motivo vc pode procurar usando a funcionalidade *Go to address* 

![alt text](image-18.png)

E procurar o dessa forma:

![alt text](image-19.png)